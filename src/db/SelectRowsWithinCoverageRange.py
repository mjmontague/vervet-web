#!/usr/bin/env python
"""
Examples:
	%s 
	
	%s -i /tmp/VCFSampleIDList.tsv --whichColumnHeader=sampleID
		--minMedianDepth 2 --maxMedianDepth 15
		-s 1.0 -o /tmp/VCFSampleIDList_medianDepth_2_15.tsv

Description:
	2012.10.15
		The input contains a column (self.whichColumnHeader) of read-groups (generated by VervetDB), 
			from which a db alignment entry is fetched and its coverage is used to include/exclude that row.
	If "-i ..." is given, it is regarded as one of the input files (plus the ones in trailing arguments). 
"""

import sys, os, math
__doc__ = __doc__%(sys.argv[0], sys.argv[0])

#bit_number = math.log(sys.maxint)/math.log(2)
#if bit_number>40:	   #64bit
#	sys.path.insert(0, os.path.expanduser('~/lib64/python'))
#	sys.path.insert(0, os.path.join(os.path.expanduser('~/script64')))
#else:   #32bit
sys.path.insert(0, os.path.expanduser('~/lib/python'))
sys.path.insert(0, os.path.join(os.path.expanduser('~/script')))

import csv
from pymodule import ProcessOptions, getListOutOfStr, PassingData, getColName2IndexFromHeader, figureOutDelimiter
from pymodule import yh_matplotlib, SNP
import numpy, random
from pymodule.AbstractMatrixFileWalker import AbstractMatrixFileWalker
from vervet.src import VervetDB, AbstractVervetMapper

class SelectRowsWithinCoverageRange(AbstractMatrixFileWalker, AbstractVervetMapper):
	__doc__ = __doc__
	option_default_dict = AbstractMatrixFileWalker.option_default_dict.copy()
	option_default_dict.update(AbstractMatrixFileWalker.db_option_dict.copy())
	option_default_dict[('minNoOfTotal', 1, int)][0] = 0
	option_default_dict.update({
						('minMedianDepth', 0, float): [None, '', 1, 'minimum median depth of the alignment of a sample (id=ReadGroup)'],\
						('maxMedianDepth', 0, float): [None, '', 1, 'max median depth'],\
						})
	def __init__(self, inputFnameLs=None, **keywords):
		"""
		"""
		AbstractMatrixFileWalker.__init__(self, inputFnameLs=inputFnameLs, **keywords)
		#self.connectDB() called within its __init__()
	
	def connectDB(self):
		"""
		2012.10.15
		"""
		AbstractVervetMapper.connectDB(self)
	
	def processRow(self, row=None, pdata=None):
		"""
		2012.10.7
		"""
		returnValue = 0
		col_name2index = getattr(pdata, 'col_name2index', None)
		if col_name2index:
			if self.whichColumnHeader:
				whichColumnIndex = col_name2index.get(self.whichColumnHeader, None)
			else:
				whichColumnIndex = self.whichColumn
			whichColumnValue = row[whichColumnIndex]
			individualAlignment = self.db_vervet.parseAlignmentReadGroup(whichColumnValue).individualAlignment
			if individualAlignment and individualAlignment.median_depth and \
					(self.minMedianDepth and individualAlignment.median_depth>=self.minMedianDepth) and\
					(self.maxMedianDepth and individualAlignment.median_depth<=self.maxMedianDepth):
				self.invariantPData.writer.writerow(row)
				returnValue = 1
		return returnValue
	
if __name__ == '__main__':
	main_class = SelectRowsWithinCoverageRange
	po = ProcessOptions(sys.argv, main_class.option_default_dict, error_doc=main_class.__doc__)
	instance = main_class(po.arguments, **po.long_option2value)
	instance.run()